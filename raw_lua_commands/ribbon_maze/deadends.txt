-- 1 is valid path, 0 is wall
local function reverse_table(t)
    local reversedTable = {}
    local itemCount = #t
    for k, v in ipairs(t) do
        reversedTable[itemCount + 1 - k] = v
    end
    return reversedTable
end

local function get_maze_width_from_map_settings(n)
    if n % 2 == 0 then
     return n + 3
    else
     return n + 2
    end
end

local function last_line_blocked_line(maze_table)
    if #maze_table < 2 then
        return false
    else
        for _, val in ipairs(maze_table[#maze_table]) do
            if val == 1 then
                return false
            end
        end
        return true
    end
end

local maze = {}
local maze_map_width_setting = settings.global['ribbon-maze-blocks']['value']
local map_width = get_maze_width_from_map_settings(maze_map_width_setting)

local block_offset = settings.global['ribbon-maze-block-size']['value']

local spawn_chunk_x = 16
local spawn_chunk_y = 16
local num_blocks_to_leftmost = math.floor((map_width-1)/2)
local left_maze_x = spawn_chunk_x - (num_blocks_to_leftmost*block_offset)
local bottom_maze_y = spawn_chunk_y + 1*block_offset

local cur_y = bottom_maze_y
local tile_walls_names = {'water-green', 'water', 'landfill'}

local function is_wall(x,y)
    if y < -100000 then
        return 0
    end
    if not game.forces['player'].is_chunk_charted(game.surfaces[1], {math.floor(x/32),math.floor(y/32)}) then
        return 0
    end

    block_tile_name = game.surfaces[1].get_tile(x,y).name
    if block_tile_name == 'water-green' or block_tile_name == 'water' or block_tile_name == 'landfill' then
        return 0
    else
        return 1
    end
end

repeat
    table.insert(maze, {})
    for i = 1,map_width,1 do
        local cur_x = left_maze_x+(i-1)*block_offset
        local path_status = is_wall(cur_x, cur_y)
        table.insert(maze[#maze], path_status)
    end
    cur_y = cur_y - block_offset
until( last_line_blocked_line(maze) )

maze = reverse_table(maze)

local deadends = 0
for row_idx, row in ipairs(maze) do
 for col_idx, col in ipairs(row) do
  if maze[row_idx][col_idx] == 1 then
   local num_blocked_sides = 0
   -- check right
   if col_idx + 1 <= #row then
    if maze[row_idx][col_idx + 1] == 0 then
     num_blocked_sides = num_blocked_sides + 1
    end
   end
   -- check up
   if row_idx - 1 >= 1 then
    if maze[row_idx - 1][col_idx] == 0 then
     num_blocked_sides = num_blocked_sides + 1
    end
   end
   -- check left
   if col_idx - 1 >= 1 then
    if maze[row_idx][col_idx - 1] == 0 then
     num_blocked_sides = num_blocked_sides + 1
    end
   end
   -- check down
   if row_idx + 1 <= #maze then
    if maze[row_idx + 1][col_idx] == 0 then
     num_blocked_sides = num_blocked_sides + 1
    end
   end

   if num_blocked_sides == 3 then
    deadends = deadends + 1
   end
  end
 end
end

game.player.print(deadends)
